# 「C」指针

## 指针基础

1. 指针，名如其实，指向一个已有的变量，自身的大小为8bit(64byte的电脑)，代表已知变量的地址（抽象地址，非内存实际地址），地址是局部变量（只有传递出去才可被函数调用）

2. 内存中，每个内存容器中装有一个值，变量指向值，指针指向容器。指针为双向链接

3. 指针初始化必须指向一个已知变量，或者NULL，否则野指针

   1. `int *pInt `:初始化int类型指针

      1. 此时，pInt可以悬空，在接下来`pInt=&a`
      2. `*pInt `无意义，不能给pInt赋值

   2. `int *pInt=&a`:pInt为变量a的地址

      注意，在初始化后指针重新指向只能`pInt = &a`
      
   2. `void *p`通用类型的指针

      1. p被赋值无需强制类型转换
      2. `int *a=(int *)p`:一般指针赋值通用指针，需要强制类型转换

4. 两个指针的运算：最高优先级

   1. 「*」取值运算符，获得指针对应的变量的值
   2. 「&」取址运算符，获得变量的地址
   3. 优先级问题,若`p[2]={1,10}`
      1. `(*p)++`:p=2
      2. `*(p++)`:p=10

## 指针的使用

### 指针与函数

#### 指针作为参数

##### 例：两个数的交换

1. 全局变量：换容器中的值

2. 指针传入函数：换容器

   ``` c
   void true_swap(int *p1,int *p2 )          
   {  
   int  temp;
   temp = *p1;
   *p1 = *p2;
   *p2 = temp;
    } 
   ```
   注意：true_swap函数在接受到指针参数后，对值进行操作，可以达成目的。下面两个函数依旧对变量进行操作，无法达成目的。

   ```c
   void false_swap (int *p1，int *p2)
    { int  *p；
       p =p1；
       p1 =p2；
       p2 =p；
      }
   
   ```
   
   ```c
   void false_swap (int p1，int p2)
    { int  p；
       p =p1；
       p1 =p2；
       p2 =p；
      }
   
   ```

#### 返回指针的函数

初始化类似：`int  *search(int *x，int n);`其中，search是函数名

#### 函数的指针

初始化类似`   (*p)(a，b)；`其中`（*p）`是函数名

作用：函数的嵌套调用（将函数视为一个变量，可以被其他函数调用）

```c
int max(int x,int y)
{   printf(“max=”);
     return(x>y?x:y);
}
int min(int x,int y)
{    printf(“min=”);
      return(x<y?x:y);
}
int add(int x,int y)
{   printf(“sum=”);  
     return(x+y);
}
void process(int x,int y,int (*fun)(int, int))//process可以缩减同类型函数（其返回值格式类似）
{  int result;
    result = (*fun)(x, y);
    printf("%d\n", result);
}
int main()
{  int a,b;
    scanf("%d,%d", &a, &b);
    process(a, b, max);//main函数内可以以参数的形式指定调用的函数
    process(a, b, min);
    process(a, b, add);
    return 0;
}

```





### 指针与数组

1. 数组名即为首元素指针，指针也可以代表首元素的数组，二者可以互换

   1. 数组名的指针为一个常量，不能指向其他的值
   2. 在函数中传递数组，只需要传递数组名，就是这个原理

2. `*(p++)`代表在一个元素（如果int类型数组，则后移4位）

3. `*(p+a)`代表后移a个元素，实际移动`a*sizeof()`的长度

4. 多维数组

   1. 指针的嵌套问题：指针指向一个指针

      1. ```c
         for(int i=0;i<2;i++)
            {
               for(int j=0;j<2;j++)
               {
                  printf("%d ",*(*(a+i)+j));
                 //printf("%d ",a[i][j]);
                 //两行代码等价
               }
               printf("\n");
            }
         ```
         数组名a为最内层指针名，`*(a+i)`代表第i行的第一个元素的地址（也可以理解为一个低维数组名），`*(*(a+i)+j)`为第i行第j列的元素
         
      2. 二维数组的地址仍然连续顺序为
      
         ```shell
         1 6d80b370 2 6d80b374 
         3 6d80b378 4 6d80b37c 
         ```
      
   1. 二维数组的初始化
   
      ```c
      int *(p1[5]);  //指针数组，可以去掉括号直接写作 int *p1[5];
      int (*p2)[5];  //二维数组指针，不能去掉括号
      ```
      1. 指针数组是**一个数组**，只是每个元素保存的都是指针，以上面的 p1 为例，在32位环境下它占用 4×5 = 20 个字节的内存。
      1. 二维数组指针是**一个指针**，它指向一个二维数组，以上面的 p2 为例，它占用 4 个字节的内存。

### 指针与字符串

#### 一维

字符串与数组基本相同，但有少许区别：

1. 指针可以重复赋值

   ``` c 
   char *p="Hello World";
   p="test to reHello World";
   ```

2. 数组可以变更其中的一个值

可以理解为：数组存储了一个值，指针没有存储，只是链接到了一个值

#### 二维(多个字符串)

1. 数据的存储方式与大小（字符串占用空间更小）<img src="https://cdn.jsdelivr.net/gh/TANG617/images@master/2021%2012%2015%2020%2010%2050%20_image-20211215201050169.png" alt="image-20211215201050169" style="zoom:50%;" />

2. 初始化

   ```c
   char *a[]={"12","34","56","78"};
   ```

   类似指针数组的初始化，一维数组`a[MAXN]`中每个元素为一个指针，指针分别指向`"12""34""56""78"`的首元素地址

   `MAXN`为元素的个数，无需指定元素的长度（`sizeof(a)=MAXN*8`）
   
3. 访问
   
   1. `a[i]`代表第i个字符串的首地址
   2. `printf("%s")`后的参数可以视为一维字符串的首地址，可以传入`a[i]`来输出一整个字符串
   3. 也可以`*(a[i]+j)`或者`(*(a+i)+j)`来访问单一的元素





















